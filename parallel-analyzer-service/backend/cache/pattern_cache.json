{
  "4459df57790d6cc35594493c13f4a346b2d9f3bda9eb174dbab9cda1013ecf85": {
    "analysis": {
      "classification": "requires_analysis",
      "reasoning": "Individual candidate analysis",
      "confidence": 0.7,
      "transformations": [],
      "tests_recommended": [],
      "logic_issue_type": "none",
      "analysis_source": "ai_llm"
    },
    "timestamp": 1759257189.3389509,
    "usage_count": 1,
    "pattern_hash": "4459df57790d6cc35594493c13f4a346b2d9f3bda9eb174dbab9cda1013ecf85",
    "original_code_snippet": "// Dot product - reduction with two arrays\ndouble dotProduct(const std::vector<double>& a, const std::vector<double>& b) {\n    double sum = 0.0;\n    for (size_t i = 0; i < a.size(); i++) {\n        sum",
    "confidence": 0.7
  },
  "262ebf74ce48cf7c15547e3fed25ae22b3ea950ecce56600f5e98b8ca9751cac": {
    "analysis": {
      "classification": "requires_analysis",
      "reasoning": "Individual candidate analysis",
      "confidence": 0.7,
      "transformations": [],
      "tests_recommended": [],
      "logic_issue_type": "none",
      "analysis_source": "ai_llm"
    },
    "timestamp": 1759257189.339505,
    "usage_count": 1,
    "pattern_hash": "262ebf74ce48cf7c15547e3fed25ae22b3ea950ecce56600f5e98b8ca9751cac",
    "original_code_snippet": "// Simple reduction - sum\ndouble sumReduction(const std::vector<double>& data) {\n    double sum = 0.0;\n    for (size_t i = 0; i < data.size(); i++) {\n        sum += data[i];\n    }\n    return sum;",
    "confidence": 0.7
  },
  "5d9d9ea1371008cfdb32e56a4e26cf70f6b3edfcbbaf9cca4764ba9fd0b0f32c": {
    "analysis": {
      "classification": "requires_analysis",
      "reasoning": "Individual candidate analysis",
      "confidence": 0.7,
      "transformations": [],
      "tests_recommended": [],
      "logic_issue_type": "none",
      "analysis_source": "ai_llm"
    },
    "timestamp": 1759257189.3402398,
    "usage_count": 1,
    "pattern_hash": "5d9d9ea1371008cfdb32e56a4e26cf70f6b3edfcbbaf9cca4764ba9fd0b0f32c",
    "original_code_snippet": "    for (size_t i = 1; i < data.size(); i++) {\n        if (data[i] > maxVal) {\n            maxVal = data[i];\n        }\n    }\n    return maxVal;\n}",
    "confidence": 0.7
  },
  "48aa6a7219abcee8872ce20f364581636746af15e0d8fa3b0bee2b8f602059b4": {
    "analysis": {
      "classification": "requires_analysis",
      "reasoning": "Individual candidate analysis",
      "confidence": 0.7,
      "transformations": [],
      "tests_recommended": [],
      "logic_issue_type": "none",
      "analysis_source": "ai_llm"
    },
    "timestamp": 1759257189.340798,
    "usage_count": 1,
    "pattern_hash": "48aa6a7219abcee8872ce20f364581636746af15e0d8fa3b0bee2b8f602059b4",
    "original_code_snippet": "std::vector<double> runningSum(const std::vector<double>& data) {\n    std::vector<double> result(data.size());\n    result[0] = data[0];\n    for (size_t i = 1; i < data.size(); i++) {\n        result[i]",
    "confidence": 0.7
  },
  "7c17e38a274b60f4f161d5c8bcab39ef8a9e8414b23151bc16b2548b67091b3b": {
    "analysis": {
      "classification": "requires_analysis",
      "reasoning": "Individual candidate analysis",
      "confidence": 0.7,
      "transformations": [],
      "tests_recommended": [],
      "logic_issue_type": "none",
      "analysis_source": "ai_llm"
    },
    "timestamp": 1759257189.341632,
    "usage_count": 1,
    "pattern_hash": "7c17e38a274b60f4f161d5c8bcab39ef8a9e8414b23151bc16b2548b67091b3b",
    "original_code_snippet": "// Max reduction\ndouble maxReduction(const std::vector<double>& data) {\n    double maxVal = data[0];\n    for (size_t i = 1; i < data.size(); i++) {\n        if (data[i] > maxVal) {\n            maxVal =",
    "confidence": 0.7
  },
  "62c4db58e6eba87b246f0c21c745358b660291abfc8cca5cb023840c38867bd6": {
    "analysis": {
      "classification": "requires_analysis",
      "reasoning": "Individual candidate analysis",
      "confidence": 0.7,
      "transformations": [],
      "tests_recommended": [],
      "logic_issue_type": "none",
      "analysis_source": "ai_llm"
    },
    "timestamp": 1759257209.472894,
    "usage_count": 1,
    "pattern_hash": "62c4db58e6eba87b246f0c21c745358b660291abfc8cca5cb023840c38867bd6",
    "original_code_snippet": "};\n\nvoid matrixAdd(const Matrix& A, const Matrix& B, Matrix& C) {\n    for (size_t i = 0; i < A.rows; ++i) {\n        for (size_t j = 0; j < A.cols; ++j) {\n            C.data[i][j] = A.data[i][j] + B.da",
    "confidence": 0.7
  },
  "6cc3f0e59ce6202ae174c36a597b8bae878a40dcdee94b39556c3b9f72f1b513": {
    "analysis": {
      "classification": "requires_analysis",
      "reasoning": "Individual candidate analysis",
      "confidence": 0.7,
      "transformations": [],
      "tests_recommended": [],
      "logic_issue_type": "none",
      "analysis_source": "ai_llm"
    },
    "timestamp": 1759257209.473763,
    "usage_count": 1,
    "pattern_hash": "6cc3f0e59ce6202ae174c36a597b8bae878a40dcdee94b39556c3b9f72f1b513",
    "original_code_snippet": "\nvoid matrixAdd(const Matrix& A, const Matrix& B, Matrix& C) {\n    for (size_t i = 0; i < A.rows; ++i) {\n        for (size_t j = 0; j < A.cols; ++j) {\n            C.data[i][j] = A.data[i][j] + B.data[",
    "confidence": 0.7
  },
  "8c95ea39b2404cd0d72d641151de314f1346532ccba63d06cfb7c3fd65dffb5d": {
    "analysis": {
      "classification": "requires_analysis",
      "reasoning": "Individual candidate analysis",
      "confidence": 0.7,
      "transformations": [],
      "tests_recommended": [],
      "logic_issue_type": "none",
      "analysis_source": "ai_llm"
    },
    "timestamp": 1759257223.673598,
    "usage_count": 1,
    "pattern_hash": "8c95ea39b2404cd0d72d641151de314f1346532ccba63d06cfb7c3fd65dffb5d",
    "original_code_snippet": "    double kernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n    \n    for (int i = 1; i < N-1; i++) {\n        for (int j = 1; j < N-1; j++) {\n            double sum = 0.0;\n            for (int",
    "confidence": 0.7
  },
  "fd046a232c7720416b56d57859b8a8aecdf7d0be868fed07b7807a4f525cb431": {
    "analysis": {
      "classification": "requires_analysis",
      "reasoning": "Individual candidate analysis",
      "confidence": 0.7,
      "transformations": [],
      "tests_recommended": [],
      "logic_issue_type": "none",
      "analysis_source": "ai_llm"
    },
    "timestamp": 1759257223.674486,
    "usage_count": 1,
    "pattern_hash": "fd046a232c7720416b56d57859b8a8aecdf7d0be868fed07b7807a4f525cb431",
    "original_code_snippet": "    // 9-point stencil\n    \n    for (int i = 1; i < N-1; i++) {\n        for (int j = 1; j < N-1; j++) {\n            global_new_grid[i][j] = (\n                global_grid[i-1][j-1] + global_grid[i-1][j",
    "confidence": 0.7
  },
  "aa073518de576c1e8545df9efc4928b0f8076a7e46398bc6ff3fa98c17238a5a": {
    "analysis": {
      "classification": "requires_analysis",
      "reasoning": "Individual candidate analysis",
      "confidence": 0.7,
      "transformations": [],
      "tests_recommended": [],
      "logic_issue_type": "none",
      "analysis_source": "ai_llm"
    },
    "timestamp": 1759257223.675174,
    "usage_count": 1,
    "pattern_hash": "aa073518de576c1e8545df9efc4928b0f8076a7e46398bc6ff3fa98c17238a5a",
    "original_code_snippet": "    // Simple image blur\n    \n    for (int i = 1; i < M-1; i++) {\n        for (int j = 1; j < M-1; j++) {\n            int sum = global_image_big[i-1][j-1] + global_image_big[i-1][j] + global_image_big",
    "confidence": 0.7
  },
  "acb4c52a6cae58c4ca61dd43d9dd386f96666cfd6db8dff1e3424215fbf79836": {
    "analysis": {
      "classification": "requires_analysis",
      "reasoning": "Individual candidate analysis",
      "confidence": 0.7,
      "transformations": [],
      "tests_recommended": [],
      "logic_issue_type": "none",
      "analysis_source": "ai_llm"
    },
    "timestamp": 1759257223.675812,
    "usage_count": 1,
    "pattern_hash": "acb4c52a6cae58c4ca61dd43d9dd386f96666cfd6db8dff1e3424215fbf79836",
    "original_code_snippet": "    // 2D stencil - 5-point stencil (heat equation)\n    \n    for (int i = 1; i < N-1; i++) {\n        for (int j = 1; j < N-1; j++) {\n            global_new_grid[i][j] = (global_grid[i-1][j] + global_g",
    "confidence": 0.7
  },
  "fa54c4a271a56ea1cd425a116c3d6273a861a2aa0d1fc2bd022d262089361a4c": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759257972.852562,
    "usage_count": 1,
    "pattern_hash": "fa54c4a271a56ea1cd425a116c3d6273a861a2aa0d1fc2bd022d262089361a4c",
    "original_code_snippet": "\n// Another parallel candidate - element-wise multiplication\nvoid vectorMultiply(const float* a, const float* b, float* result, int n) {\n    for (int i = 0; i < n; i++) {\n        result[i] = a[i] * b[",
    "confidence": 0.95
  },
  "de687555261750d3702c3fb01de4afb812a30620ad921c9f3ecf5854b1220202": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759257972.8538508,
    "usage_count": 1,
    "pattern_hash": "de687555261750d3702c3fb01de4afb812a30620ad921c9f3ecf5854b1220202",
    "original_code_snippet": "\n// Simple parallel loop candidate - vector addition\nvoid vectorAdd(const std::vector<float>& a, const std::vector<float>& b, std::vector<float>& c) {\n    for (size_t i = 0; i < a.size(); i++) {\n     ",
    "confidence": 0.95
  },
  "a54df4cecc0fb97caadd0af04d53951a02d4215e796b81fdaaa776c4860d81d7": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759257972.854783,
    "usage_count": 1,
    "pattern_hash": "a54df4cecc0fb97caadd0af04d53951a02d4215e796b81fdaaa776c4860d81d7",
    "original_code_snippet": "// Reduction pattern - sum computation\nfloat computeSum(const std::vector<float>& data) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < data.size(); i++) {\n        sum += data[i];  // Reduction pat",
    "confidence": 0.95
  },
  "860172eb6eb7d3431870db0ded5a8519039a207a89ad3278add436784cc9a760": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759257972.855777,
    "usage_count": 1,
    "pattern_hash": "860172eb6eb7d3431870db0ded5a8519039a207a89ad3278add436784cc9a760",
    "original_code_snippet": "\n// Sequential dependency - not parallelizable\nvoid sequentialDependency(std::vector<float>& data) {\n    for (size_t i = 1; i < data.size(); i++) {\n        data[i] = data[i] + data[i-1];  // data[i] d",
    "confidence": 0.95
  },
  "d8f977f30fd2dda1ccd4badbfc0857cc9c8f279c38548445eb5cb87a1f74c618": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759863630.802216,
    "usage_count": 1,
    "pattern_hash": "d8f977f30fd2dda1ccd4badbfc0857cc9c8f279c38548445eb5cb87a1f74c618",
    "original_code_snippet": "    const int n = 1000;\n    int array[n];\n    \n    for (int i = 2; i < n; i++) {\n        array[i] = array[i-1] + array[i-2];  // Fibonacci-like dependency\n    }\n    ",
    "confidence": 0.95
  },
  "35bd0edae95ef41d095a5a453adfeee7ea8c30093fe98038aaabb1ce5ed956dc": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759863630.805237,
    "usage_count": 1,
    "pattern_hash": "35bd0edae95ef41d095a5a453adfeee7ea8c30093fe98038aaabb1ce5ed956dc",
    "original_code_snippet": "    const int n = 1000;\n    int array[n];\n    \n    for (int i = 1; i < n; i++) {\n        array[i] += array[i-1];  // Each iteration depends on previous\n    }\n    ",
    "confidence": 0.95
  },
  "c2003424a295fff5edeeb4a31387f8b5583baccf0a1a797e70f932e1754a098b": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.9,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759258681.628891,
    "usage_count": 1,
    "pattern_hash": "c2003424a295fff5edeeb4a31387f8b5583baccf0a1a797e70f932e1754a098b",
    "original_code_snippet": "    \n    // Initialize matrices\n    for (size_t i = 0; i < N; i++) {\n        for (size_t j = 0; j < N; j++) {\n            A(i, j) = static_cast<double>(i + j);\n            B(i, j) = static_cast<double",
    "confidence": 0.9
  },
  "a7cdedb388f1784d860b8756a9edf058fd7f4d6973519ba6aeea0dbd8a11e284": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759258681.630281,
    "usage_count": 1,
    "pattern_hash": "a7cdedb388f1784d860b8756a9edf058fd7f4d6973519ba6aeea0dbd8a11e284",
    "original_code_snippet": "\n// Complex pattern - matrix multiplication (trickier to parallelize)\nvoid matrixMultiply(const Matrix& A, const Matrix& B, Matrix& C) {\n    for (size_t i = 0; i < A.getRows(); i++) {\n        for (siz",
    "confidence": 0.95
  },
  "3b07dcbe1a423113f30eb64d52936ae743fc5a1d3538dd0b158e87b07f4596be": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759258681.631339,
    "usage_count": 1,
    "pattern_hash": "3b07dcbe1a423113f30eb64d52936ae743fc5a1d3538dd0b158e87b07f4596be",
    "original_code_snippet": "// Parallel candidate with reduction - matrix norm\ndouble matrixFrobeniusNorm(const Matrix& A) {\n    double sum = 0.0;\n    for (size_t i = 0; i < A.getRows(); i++) {\n        for (size_t j = 0; j < A.g",
    "confidence": 0.95
  },
  "be0191a499641434ec290e7e5613a384d15d9eb8f94bfcac46314ecf5b8a2665": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.9,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759258681.6323211,
    "usage_count": 1,
    "pattern_hash": "be0191a499641434ec290e7e5613a384d15d9eb8f94bfcac46314ecf5b8a2665",
    "original_code_snippet": "// Complex pattern - matrix multiplication (trickier to parallelize)\nvoid matrixMultiply(const Matrix& A, const Matrix& B, Matrix& C) {\n    for (size_t i = 0; i < A.getRows(); i++) {\n        for (size",
    "confidence": 0.9
  },
  "a78f1697e5a3b1744f41ed88dbde02885561d09e8f72a74d54684e0541d60c43": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759259089.486067,
    "usage_count": 1,
    "pattern_hash": "a78f1697e5a3b1744f41ed88dbde02885561d09e8f72a74d54684e0541d60c43",
    "original_code_snippet": "                    int colIndex = k * D4 + l;\n                    result[rowIndex][colIndex] = \n                        (data4D[i][j][k][l] - globalMin) / range;\n                }\n            }\n     ",
    "confidence": 0.95
  },
  "df068388708183fba56338c7b177fae18d1ea47e8fbfc903e7a477cd41397a52": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759259089.4875572,
    "usage_count": 1,
    "pattern_hash": "df068388708183fba56338c7b177fae18d1ea47e8fbfc903e7a477cd41397a52",
    "original_code_snippet": "        for (int j = 0; j < D2; j++) {\n            int rowIndex = i * D2 + j;\n            for (int k = 0; k < D3; k++) {\n                for (int l = 0; l < D4; l++) {\n                    int colIndex",
    "confidence": 0.95
  },
  "ce3663985fdb60af3c421399c06951800944affd5e2fea9f2d8477ca1b2b627d": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; risk factors detected that may complicate parallelization",
      "confidence": 0.8,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759259089.488811,
    "usage_count": 1,
    "pattern_hash": "ce3663985fdb60af3c421399c06951800944affd5e2fea9f2d8477ca1b2b627d",
    "original_code_snippet": "    for (int i = 0; i < D1; i++) {\n        for (int j = 0; j < D2; j++) {\n            for (int k = 0; k < D3; k++) {\n                for (int l = 0; l < D4; l++) {\n                    data4D[i][j][k][",
    "confidence": 0.8
  },
  "c892e9a59e114ef52665eb99e8dec4ca0826f1b455c7da4ecc392136ab34db9c": {
    "analysis": {
      "classification": "requires_runtime_check",
      "reasoning": "Static analysis identifies this as simple_loop; positive indicators found in code context",
      "confidence": 0.6,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759259089.489962,
    "usage_count": 1,
    "pattern_hash": "c892e9a59e114ef52665eb99e8dec4ca0826f1b455c7da4ecc392136ab34db9c",
    "original_code_snippet": "                        (data4D[i][j][k][l] - globalMin) / range;\n                }\n            }\n        }\n    }\n\n    return result;",
    "confidence": 0.6
  },
  "785cfde59a6ed7629c5bdaed04158bfa57351ba729669dbb591a25295fb20389": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; risk factors detected that may complicate parallelization",
      "confidence": 0.8,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759308293.664665,
    "usage_count": 1,
    "pattern_hash": "785cfde59a6ed7629c5bdaed04158bfa57351ba729669dbb591a25295fb20389",
    "original_code_snippet": "    // Populate the multi-dimensional array\n    for (int i = 0; i < NUM_RECORDS; ++i) {\n        DataRecord record;\n        for (int j = 0; j < NUM_FIELDS; ++j) {\n            // Generate a random doubl",
    "confidence": 0.8
  },
  "bc540b5ba06bd0468f5668f5dc908b5558617d8bd07f145629febaf06d49c78a": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.9,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759308293.666388,
    "usage_count": 1,
    "pattern_hash": "bc540b5ba06bd0468f5668f5dc908b5558617d8bd07f145629febaf06d49c78a",
    "original_code_snippet": "    double grandTotal = 0.0;\n    \n    // Loop through all 10,000 records\n    for (const auto& record : data) {\n        // Business Rule: Only include records where Field 1 is greater than 50.0\n       ",
    "confidence": 0.9
  },
  "8335003c888b115bb80934072e40732bcabfc914d07192e046e7f94c0f920e18": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.9,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759308293.667504,
    "usage_count": 1,
    "pattern_hash": "8335003c888b115bb80934072e40732bcabfc914d07192e046e7f94c0f920e18",
    "original_code_snippet": "    \n    // Loop through all 10,000 records\n    for (const auto& record : data) {\n        // Business Rule: Only include records where Field 1 is greater than 50.0\n        if (record.fields[1] > 50.0)",
    "confidence": 0.9
  },
  "ab79957cb0731284236dad26d473873937690e1d3cdef39d367d6ccc111ee9a9": {
    "analysis": {
      "classification": "not_parallel",
      "reasoning": "Static analysis identifies this as simple_loop; risk factors detected that may complicate parallelization",
      "confidence": 0.4,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759308293.6686459,
    "usage_count": 1,
    "pattern_hash": "ab79957cb0731284236dad26d473873937690e1d3cdef39d367d6ccc111ee9a9",
    "original_code_snippet": "        for (int j = 0; j < NUM_FIELDS; ++j) {\n            // Generate a random double value between 0.0 and 100.0\n            record.fields[j] = static_cast<double>(std::rand() % 10000) / 100.0;\n    ",
    "confidence": 0.4
  },
  "8d6d28fba08f9521efd9c07f03b95133b9f827e449a4071e3329cc6b30328ccc": {
    "analysis": {
      "classification": "not_parallel",
      "reasoning": "Static analysis identifies this as simple_loop; risk factors detected that may complicate parallelization",
      "confidence": 0.4,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759308293.669837,
    "usage_count": 1,
    "pattern_hash": "8d6d28fba08f9521efd9c07f03b95133b9f827e449a4071e3329cc6b30328ccc",
    "original_code_snippet": "            record.fields[j] = static_cast<double>(std::rand() % 10000) / 100.0;\n        }\n        data.push_back(record);\n    }\n    \n    std::cout << \"-> Data loading complete. Total elements: \" \n   ",
    "confidence": 0.4
  },
  "c0769577ce2869d310c86759c0c36b491d89e07174ab4190b6cd459aa9438494": {
    "analysis": {
      "classification": "requires_runtime_check",
      "reasoning": "Static analysis identifies this as risky; positive indicators found in code context",
      "confidence": 0.6,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759396304.597582,
    "usage_count": 1,
    "pattern_hash": "c0769577ce2869d310c86759c0c36b491d89e07174ab4190b6cd459aa9438494",
    "original_code_snippet": "    data.reserve(NUM_RECORDS); // Pre-allocate memory for efficiency\n\n    // Populate the multi-dimensional array\n    for (int i = 0; i < NUM_RECORDS; ++i) {\n        DataRecord record;\n        for (in",
    "confidence": 0.6
  },
  "b3ebbd3216797eab97f7852cbb5d06c0c93b890ce62cf0dbf543eaca2df0b0ef": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759397011.60715,
    "usage_count": 1,
    "pattern_hash": "b3ebbd3216797eab97f7852cbb5d06c0c93b890ce62cf0dbf543eaca2df0b0ef",
    "original_code_snippet": "    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            c[i][j] = 0;\n            for (k = 0; k < n; k++) {\n                c[i][j] += a[i][k] * b[k][j];\n            }\n        }",
    "confidence": 0.95
  },
  "9e1f1ce2fd1b7de89d0ef17bcb4fca2b1722dc598b52e9fab30c4c173062aec8": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759397011.608995,
    "usage_count": 1,
    "pattern_hash": "9e1f1ce2fd1b7de89d0ef17bcb4fca2b1722dc598b52e9fab30c4c173062aec8",
    "original_code_snippet": "    \n    // Initialize matrices\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            a[i][j] = i + j;\n            b[i][j] = i - j;\n        }",
    "confidence": 0.95
  },
  "3c1629d367667a05280022a6d28fe753577b1eb8012bf5325028d57935657127": {
    "analysis": {
      "classification": "requires_runtime_check",
      "reasoning": "Static analysis identifies this as simple_loop; positive indicators found in code context",
      "confidence": 0.6,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759397011.610174,
    "usage_count": 1,
    "pattern_hash": "3c1629d367667a05280022a6d28fe753577b1eb8012bf5325028d57935657127",
    "original_code_snippet": "\nvoid matrix_multiply(int** a, int** b, int** c, int n) {\n    int i, j, k;\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            c[i][j] = 0;\n            for (k = 0; k < n; k++) ",
    "confidence": 0.6
  },
  "3b64336aa08f419a6463e7faec432e41a5cb1cea9249c48e41b59836d8fabd8d": {
    "analysis": {
      "classification": "requires_runtime_check",
      "reasoning": "Static analysis identifies this as simple_loop; positive indicators found in code context",
      "confidence": 0.6,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759397011.6115048,
    "usage_count": 1,
    "pattern_hash": "3b64336aa08f419a6463e7faec432e41a5cb1cea9249c48e41b59836d8fabd8d",
    "original_code_snippet": "    }\n    \n    // Initialize matrices\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            a[i][j] = i + j;\n            b[i][j] = i - j;",
    "confidence": 0.6
  },
  "e1f0bf08cff166957fed06f1fa15c2735f53550db2576f789672f12cb17f7965": {
    "analysis": {
      "classification": "requires_runtime_check",
      "reasoning": "Static analysis identifies this as simple_loop; positive indicators found in code context",
      "confidence": 0.6,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759397094.108969,
    "usage_count": 1,
    "pattern_hash": "e1f0bf08cff166957fed06f1fa15c2735f53550db2576f789672f12cb17f7965",
    "original_code_snippet": "    double range = (globalMax == globalMin) ? 1.0 : (globalMax - globalMin);\n\n    // Fill normalized 2D array\n    for (int i = 0; i < D1; i++) {\n        for (int j = 0; j < D2; j++) {\n            int ",
    "confidence": 0.6
  },
  "8fc784ee56742e520aa99887b7e4d49923187e09744a852ba0f9606f7a9c7bfb": {
    "analysis": {
      "classification": "requires_runtime_check",
      "reasoning": "Static analysis identifies this as simple_loop; positive indicators found in code context",
      "confidence": 0.6,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759397094.1113222,
    "usage_count": 1,
    "pattern_hash": "8fc784ee56742e520aa99887b7e4d49923187e09744a852ba0f9606f7a9c7bfb",
    "original_code_snippet": "\n    // Fill normalized 2D array\n    for (int i = 0; i < D1; i++) {\n        for (int j = 0; j < D2; j++) {\n            int rowIndex = i * D2 + j;\n            for (int k = 0; k < D3; k++) {\n           ",
    "confidence": 0.6
  },
  "ba1766961384ac757ece21295b2d3dbcb6c2085c2cc92469a9113f46c93cef9d": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759410080.0092008,
    "usage_count": 1,
    "pattern_hash": "ba1766961384ac757ece21295b2d3dbcb6c2085c2cc92469a9113f46c93cef9d",
    "original_code_snippet": "\nvoid separateLoops(std::vector<double>& data) {\n    // This should be detected as a separate simple loop block\n    for (int i = 0; i < data.size(); i++) {\n        data[i] = data[i] * data[i];  // squ",
    "confidence": 0.95
  },
  "d92e59b1ea514cf53f2024a2bf1018c4e9a7f9388c4c6a0b815baaa587375f57": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759410080.01266,
    "usage_count": 1,
    "pattern_hash": "d92e59b1ea514cf53f2024a2bf1018c4e9a7f9388c4c6a0b815baaa587375f57",
    "original_code_snippet": "    double total = 0.0;\n    \n    // Outer loop - should be detected as part of nested loop block\n    for (int i = 0; i < matrix.size(); i++) {\n        double rowSum = 0.0;\n        \n        // Inner lo",
    "confidence": 0.95
  },
  "3fca6563d9bf853840927cbf096977ef5be77e7ea896a42aabdfe5b2632d231b": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759410080.01384,
    "usage_count": 1,
    "pattern_hash": "3fca6563d9bf853840927cbf096977ef5be77e7ea896a42aabdfe5b2632d231b",
    "original_code_snippet": "        double rowSum = 0.0;\n        \n        // Inner loop - vectorizable computation within nested structure  \n        for (int j = 0; j < matrix[i].size(); j++) {\n            rowSum += matrix[i][j]",
    "confidence": 0.95
  },
  "cfed57cf42f4b87598823b211194a82b3047674d055f60b11b45bd17c6a5c8bd": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759412545.370371,
    "usage_count": 1,
    "pattern_hash": "cfed57cf42f4b87598823b211194a82b3047674d055f60b11b45bd17c6a5c8bd",
    "original_code_snippet": "};\n\nvoid processData(const std::vector<DataRecord>& data) {\n    for (const auto& record : data) { // Line 59 - should have vectorizable + risky\n        if (record.field > 0) {\n            std::cout <<",
    "confidence": 0.95
  },
  "d15bd849665e64f6a28b67db37fead8a6b716265fc6946e64c0dcb3364726498": {
    "analysis": {
      "classification": "requires_runtime_check",
      "reasoning": "Static analysis identifies this as simple_loop; positive indicators found in code context",
      "confidence": 0.6,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759412545.3728168,
    "usage_count": 1,
    "pattern_hash": "d15bd849665e64f6a28b67db37fead8a6b716265fc6946e64c0dcb3364726498",
    "original_code_snippet": "\nvoid processData(const std::vector<DataRecord>& data) {\n    for (const auto& record : data) { // Line 59 - should have vectorizable + risky\n        if (record.field > 0) {\n            std::cout << re",
    "confidence": 0.6
  },
  "e43e250478ccad8b42cf1bd768f8b47fc8a924e1839dec3116fe71ee211bbc3b": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759412569.1661608,
    "usage_count": 1,
    "pattern_hash": "e43e250478ccad8b42cf1bd768f8b47fc8a924e1839dec3116fe71ee211bbc3b",
    "original_code_snippet": "    \n    // Complex nested loop with data processing\n    for (const auto& record : data) {  // Line 59 - multiple analysis types\n        if (record.active && record.value > 10.0) {\n            sum += ",
    "confidence": 0.95
  },
  "37701c4e7e466b29e828f7f051120872a69a0ea79e7aa9e36ced27c08b61c382": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759412569.169107,
    "usage_count": 1,
    "pattern_hash": "37701c4e7e466b29e828f7f051120872a69a0ea79e7aa9e36ced27c08b61c382",
    "original_code_snippet": "    int count = 0;\n    \n    // Complex nested loop with data processing\n    for (const auto& record : data) {  // Line 59 - multiple analysis types\n        if (record.active && record.value > 10.0) {\n",
    "confidence": 0.95
  },
  "dcb9a7460019441d8990a8c24c6c27b53a9e1cd2fc3bbe8eccec6b5d0587d7ee": {
    "analysis": {
      "classification": "not_parallel",
      "reasoning": "Static analysis identifies this as simple_loop; positive indicators found in code context",
      "confidence": 0.55,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759412569.171156,
    "usage_count": 1,
    "pattern_hash": "dcb9a7460019441d8990a8c24c6c27b53a9e1cd2fc3bbe8eccec6b5d0587d7ee",
    "original_code_snippet": "        if (record.active && record.value > 10.0) {\n            sum += record.value;\n            count++;\n            std::cout << record.name << \": \" << record.value << std::endl;\n        }\n    }\n   ",
    "confidence": 0.55
  },
  "c301b282821ee5fd1886d6b0df14bb3b2b31336ff05a0b1ac5e6c08a98581519": {
    "analysis": {
      "classification": "requires_runtime_check",
      "reasoning": "Static analysis identifies this as risky; positive indicators found in code context",
      "confidence": 0.6,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759412569.172443,
    "usage_count": 1,
    "pattern_hash": "c301b282821ee5fd1886d6b0df14bb3b2b31336ff05a0b1ac5e6c08a98581519",
    "original_code_snippet": "    std::vector<DataRecord> data;\n    data.reserve(1000);  // Line 30\n    \n    for (int i = 0; i < 1000; ++i) {  // Line 32\n        DataRecord record;\n        record.id = i;\n        record.name = \"Ite",
    "confidence": 0.6
  },
  "f2a78f93fca0c70ca32eb6a1f5fd92f131e54b277c5bcdd6f77a494dbcacf9a0": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759412592.916456,
    "usage_count": 1,
    "pattern_hash": "f2a78f93fca0c70ca32eb6a1f5fd92f131e54b277c5bcdd6f77a494dbcacf9a0",
    "original_code_snippet": "    \n    // Complex nested loop with data processing\n    for (const auto& record : data) {  // Line 59 - previously had vectorizable + risky\n        if (record.active && record.value > 10.0) {\n       ",
    "confidence": 0.95
  },
  "87d7051ff9b6977c19ef50a973564f0f071b90587ae050ff1110bf36f4b37f77": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759412592.919146,
    "usage_count": 1,
    "pattern_hash": "87d7051ff9b6977c19ef50a973564f0f071b90587ae050ff1110bf36f4b37f77",
    "original_code_snippet": "    int count = 0;\n    \n    // Complex nested loop with data processing\n    for (const auto& record : data) {  // Line 59 - previously had vectorizable + risky\n        if (record.active && record.valu",
    "confidence": 0.95
  },
  "d6eae3f05f4b85dd381fbe91eb87969f1bcbfd80513d4df3cdc7e00f99c4220b": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759412649.972888,
    "usage_count": 1,
    "pattern_hash": "d6eae3f05f4b85dd381fbe91eb87969f1bcbfd80513d4df3cdc7e00f99c4220b",
    "original_code_snippet": "    \n    // This loop at line 59 should generate multiple analysis results\n    for (const auto& record : data) {  // Line 59 - range-based for loop\n        if (record.active && record.value > 10.0) {\n",
    "confidence": 0.95
  },
  "d6185840acbee7355cefc9214a3902751f5d5b491321e55ae20ef19cfdfec8c0": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759412649.974962,
    "usage_count": 1,
    "pattern_hash": "d6185840acbee7355cefc9214a3902751f5d5b491321e55ae20ef19cfdfec8c0",
    "original_code_snippet": "    results.reserve(data.size());\n    \n    // This loop at line 59 should generate multiple analysis results\n    for (const auto& record : data) {  // Line 59 - range-based for loop\n        if (record",
    "confidence": 0.95
  },
  "7426a63a1fb8fd2f14a1cbe55e7566bad3ceda963de88410f0335ea6a90c845c": {
    "analysis": {
      "classification": "requires_runtime_check",
      "reasoning": "Static analysis identifies this as risky; positive indicators found in code context",
      "confidence": 0.6,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759412649.976504,
    "usage_count": 1,
    "pattern_hash": "7426a63a1fb8fd2f14a1cbe55e7566bad3ceda963de88410f0335ea6a90c845c",
    "original_code_snippet": "    std::vector<DataRecord> data;\n    data.reserve(1000);  // Line 30 - memory allocation\n    \n    for (int i = 0; i < 1000; ++i) {  // Line 32 - vectorizable loop\n        DataRecord record;\n        r",
    "confidence": 0.6
  },
  "f03ddd0c5c49a04e5beb42537a471d01db4d69c7a56056de8915aab388900fb5": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759412703.109633,
    "usage_count": 1,
    "pattern_hash": "f03ddd0c5c49a04e5beb42537a471d01db4d69c7a56056de8915aab388900fb5",
    "original_code_snippet": "    \n    // Complex loop with multiple analysis patterns - line 38/39 should generate duplicates\n    for (const auto& record : data) {  // Line 38 - complex loop analysis\n        if (record.active && ",
    "confidence": 0.95
  },
  "eb7cced39883c85ba67d0f409582f26a8f44fa3717dc5d692191a95070632688": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759412703.1118138,
    "usage_count": 1,
    "pattern_hash": "eb7cced39883c85ba67d0f409582f26a8f44fa3717dc5d692191a95070632688",
    "original_code_snippet": "    results.reserve(data.size());\n    \n    // Complex loop with multiple analysis patterns - line 38/39 should generate duplicates\n    for (const auto& record : data) {  // Line 38 - complex loop anal",
    "confidence": 0.95
  },
  "5ca7d3174849355bf8a96dddc3b61d924e97c07c50b91847b1bc82d6de7ca5bf": {
    "analysis": {
      "classification": "not_parallel",
      "reasoning": "Static analysis identifies this as simple_loop; positive indicators found in code context",
      "confidence": 0.55,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759838914.792981,
    "usage_count": 1,
    "pattern_hash": "5ca7d3174849355bf8a96dddc3b61d924e97c07c50b91847b1bc82d6de7ca5bf",
    "original_code_snippet": "    // 2D convolution with 3x3 kernel\n    double kernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n    \n    for (int i = 1; i < N-1; i++) {\n        for (int j = 1; j < N-1; j++) {\n            ",
    "confidence": 0.55
  },
  "457bc5a79106fbee5d8b58a0080a23ca2f7e10c9732bc043931ab9201ece5d53": {
    "analysis": {
      "classification": "not_parallel",
      "reasoning": "Static analysis identifies this as simple_loop; positive indicators found in code context",
      "confidence": 0.55,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759838914.796268,
    "usage_count": 1,
    "pattern_hash": "457bc5a79106fbee5d8b58a0080a23ca2f7e10c9732bc043931ab9201ece5d53",
    "original_code_snippet": "    for (int i = 1; i < N-1; i++) {\n        for (int j = 1; j < N-1; j++) {\n            double sum = 0.0;\n            for (int ki = -1; ki <= 1; ki++) {\n                for (int kj = -1; kj <= 1; kj++",
    "confidence": 0.55
  },
  "a95332e544d9e59c7f675397119a3123a37fdb900fc554ede232f42b9975f9f1": {
    "analysis": {
      "classification": "requires_runtime_check",
      "reasoning": "Static analysis identifies this as simple_loop; positive indicators found in code context",
      "confidence": 0.6,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759838914.7976792,
    "usage_count": 1,
    "pattern_hash": "a95332e544d9e59c7f675397119a3123a37fdb900fc554ede232f42b9975f9f1",
    "original_code_snippet": "void stencil_2d_9point() {\n    // 9-point stencil\n    \n    for (int i = 1; i < N-1; i++) {\n        for (int j = 1; j < N-1; j++) {\n            global_new_grid[i][j] = (\n                global_grid[i-1",
    "confidence": 0.6
  },
  "506d8bee5c97e33967a8db0e09d7e3aa99b4c9ff187d12da346adb71437549db": {
    "analysis": {
      "classification": "requires_runtime_check",
      "reasoning": "Static analysis identifies this as simple_loop; positive indicators found in code context",
      "confidence": 0.6,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759838914.799285,
    "usage_count": 1,
    "pattern_hash": "506d8bee5c97e33967a8db0e09d7e3aa99b4c9ff187d12da346adb71437549db",
    "original_code_snippet": "void image_blur() {\n    // Simple image blur\n    \n    for (int i = 1; i < M-1; i++) {\n        for (int j = 1; j < M-1; j++) {\n            int sum = global_image_big[i-1][j-1] + global_image_big[i-1][j",
    "confidence": 0.6
  },
  "86802635c968ffd3e0eabedf3bbfb02d1ee9b4457af563a0009e5c7c0a447825": {
    "analysis": {
      "classification": "requires_runtime_check",
      "reasoning": "Static analysis identifies this as simple_loop; positive indicators found in code context",
      "confidence": 0.6,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759838914.8028102,
    "usage_count": 1,
    "pattern_hash": "86802635c968ffd3e0eabedf3bbfb02d1ee9b4457af563a0009e5c7c0a447825",
    "original_code_snippet": "void stencil_2d_simple() {\n    // 2D stencil - 5-point stencil (heat equation)\n    \n    for (int i = 1; i < N-1; i++) {\n        for (int j = 1; j < N-1; j++) {\n            global_new_grid[i][j] = (glo",
    "confidence": 0.6
  },
  "6f4a2034803d77786d050741d96dead34cecc9bebdbc0898edb75545c574fe36": {
    "analysis": {
      "classification": "not_parallel",
      "reasoning": "Static analysis identifies this as risky; positive indicators found in code context",
      "confidence": 0.55,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759838914.814226,
    "usage_count": 1,
    "pattern_hash": "6f4a2034803d77786d050741d96dead34cecc9bebdbc0898edb75545c574fe36",
    "original_code_snippet": "        for (int j = 1; j < N-1; j++) {\n            double sum = 0.0;\n            for (int ki = -1; ki <= 1; ki++) {\n                for (int kj = -1; kj <= 1; kj++) {\n                    sum += globa",
    "confidence": 0.55
  },
  "e18ace3f4f7fa94f9e75cb196c26ae234cfb57b40c5b5941540db646b0ffbe3c": {
    "analysis": {
      "classification": "not_parallel",
      "reasoning": "Static analysis identifies this as risky; positive indicators found in code context",
      "confidence": 0.55,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759844132.7502668,
    "usage_count": 1,
    "pattern_hash": "e18ace3f4f7fa94f9e75cb196c26ae234cfb57b40c5b5941540db646b0ffbe3c",
    "original_code_snippet": "    const int n = 100;\n    int data[n];\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"Processing item %d: %d\\n\", i, data[i]);  // I/O side effect\n    }\n    ",
    "confidence": 0.55
  },
  "502f2eb9f81c9b90a5c4eed7a5b45328d1f9b87145f5dff7ed0b3bc0ea35568b": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759845599.276211,
    "usage_count": 1,
    "pattern_hash": "502f2eb9f81c9b90a5c4eed7a5b45328d1f9b87145f5dff7ed0b3bc0ea35568b",
    "original_code_snippet": "    // Detect collisions in each cell\n    void detectCollisions(std::vector<Target>& targets) {\n        // PARALLELIZABLE\n        for (auto& cell : cells) {\n            for (Bullet* b : cell.bullets) ",
    "confidence": 0.95
  },
  "37170ee7ff8f2a69dea8b63d2f2249d670eed3d5994456cd9dc499d12d028c7d": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759845599.279577,
    "usage_count": 1,
    "pattern_hash": "37170ee7ff8f2a69dea8b63d2f2249d670eed3d5994456cd9dc499d12d028c7d",
    "original_code_snippet": "    void detectCollisions(std::vector<Target>& targets) {\n        // PARALLELIZABLE\n        for (auto& cell : cells) {\n            for (Bullet* b : cell.bullets) {\n                for (Target* t : cel",
    "confidence": 0.95
  },
  "0887f11bbb3aec23b8735e7ffbbf975b059eae1aa4bcf09e14f411df6cfcc64f": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759845599.2812219,
    "usage_count": 1,
    "pattern_hash": "0887f11bbb3aec23b8735e7ffbbf975b059eae1aa4bcf09e14f411df6cfcc64f",
    "original_code_snippet": "        // PARALLELIZABLE\n        for (auto& cell : cells) {\n            for (Bullet* b : cell.bullets) {\n                for (Target* t : cell.targets) {\n                    float dx = b->position.x ",
    "confidence": 0.95
  },
  "62df74447769e3da5336e9b7e8ece58813690063399cf11da3a03f443002b0fa": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; risk factors detected that may complicate parallelization",
      "confidence": 0.8999999999999999,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759845599.2829812,
    "usage_count": 1,
    "pattern_hash": "62df74447769e3da5336e9b7e8ece58813690063399cf11da3a03f443002b0fa",
    "original_code_snippet": "\n    void spawn(const Vec2& p, int count) {\n        for (int i=0;i<count && i<(int)parts.size();++i) {\n            if (!parts[i].active) {\n                parts[i].pos = p;\n                parts[i].ve",
    "confidence": 0.8999999999999999
  },
  "0d8d7208f9211a05d9de628ee61cf7b6758b8709ab56301e63bcffcf36f5d80e": {
    "analysis": {
      "classification": "not_parallel",
      "reasoning": "Static analysis identifies this as simple_loop; positive indicators found in code context",
      "confidence": 0.55,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759845599.2849238,
    "usage_count": 1,
    "pattern_hash": "0d8d7208f9211a05d9de628ee61cf7b6758b8709ab56301e63bcffcf36f5d80e",
    "original_code_snippet": "    auto start = std::chrono::high_resolution_clock::now();\n    for (int frame=0; frame<200; ++frame) {\n        world.update(0.016f); // ~60fps step\n        if (frame % 20 == 0) {\n            std::cou",
    "confidence": 0.55
  },
  "2875fe0394748288c82076fc507e9946b7b8828bf0aef9283cd943620ec52976": {
    "analysis": {
      "classification": "not_parallel",
      "reasoning": "Static analysis identifies this as risky; positive indicators found in code context",
      "confidence": 0.55,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759845599.286808,
    "usage_count": 1,
    "pattern_hash": "2875fe0394748288c82076fc507e9946b7b8828bf0aef9283cd943620ec52976",
    "original_code_snippet": "                    float dy = b->position.y - t->pos.y;\n                    float dist2 = dx * dx + dy * dy;\n                    float r = b->type->radius + t->radius;\n                    if (dist2 <",
    "confidence": 0.55
  },
  "72fdfc8cd868891cb260941835bb8f079190f9b488843f98b028a5d4e911c9b2": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759912667.273942,
    "usage_count": 1,
    "pattern_hash": "72fdfc8cd868891cb260941835bb8f079190f9b488843f98b028a5d4e911c9b2",
    "original_code_snippet": "    }\n    \n    // Complex loop with dependencies that AI should catch\n    for (int i = 1; i < 1000; i++) {\n        data[i] = data[i-1] + i;  // Sequential dependency - NOT parallelizable\n    }\n    ",
    "confidence": 0.95
  },
  "3d2544a62799c3356db9103983cde8c0852a3db13b5e7812f40608e72e6adebf": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759912667.2765708,
    "usage_count": 1,
    "pattern_hash": "3d2544a62799c3356db9103983cde8c0852a3db13b5e7812f40608e72e6adebf",
    "original_code_snippet": "    std::vector<int> data(1000);\n    \n    // Simple loop that should be easily parallelizable\n    for (int i = 0; i < 1000; i++) {\n        data[i] = i * 2;  // No dependencies, perfect for paralleliza",
    "confidence": 0.95
  }
}