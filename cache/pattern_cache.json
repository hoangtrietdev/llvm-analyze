{
  "72fdfc8cd868891cb260941835bb8f079190f9b488843f98b028a5d4e911c9b2": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833315.287071,
    "usage_count": 1,
    "pattern_hash": "72fdfc8cd868891cb260941835bb8f079190f9b488843f98b028a5d4e911c9b2",
    "original_code_snippet": "    }\n    \n    // Complex loop with dependencies that AI should catch\n    for (int i = 1; i < 1000; i++) {\n        data[i] = data[i-1] + i;  // Sequential dependency - NOT parallelizable\n    }\n    ",
    "confidence": 0.95
  },
  "3d2544a62799c3356db9103983cde8c0852a3db13b5e7812f40608e72e6adebf": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833315.287648,
    "usage_count": 1,
    "pattern_hash": "3d2544a62799c3356db9103983cde8c0852a3db13b5e7812f40608e72e6adebf",
    "original_code_snippet": "    std::vector<int> data(1000);\n    \n    // Simple loop that should be easily parallelizable\n    for (int i = 0; i < 1000; i++) {\n        data[i] = i * 2;  // No dependencies, perfect for paralleliza",
    "confidence": 0.95
  },
  "c2003424a295fff5edeeb4a31387f8b5583baccf0a1a797e70f932e1754a098b": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.9,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833315.894759,
    "usage_count": 1,
    "pattern_hash": "c2003424a295fff5edeeb4a31387f8b5583baccf0a1a797e70f932e1754a098b",
    "original_code_snippet": "    \n    // Initialize matrices\n    for (size_t i = 0; i < N; i++) {\n        for (size_t j = 0; j < N; j++) {\n            A(i, j) = static_cast<double>(i + j);\n            B(i, j) = static_cast<double",
    "confidence": 0.9
  },
  "a7cdedb388f1784d860b8756a9edf058fd7f4d6973519ba6aeea0dbd8a11e284": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833315.895506,
    "usage_count": 1,
    "pattern_hash": "a7cdedb388f1784d860b8756a9edf058fd7f4d6973519ba6aeea0dbd8a11e284",
    "original_code_snippet": "\n// Complex pattern - matrix multiplication (trickier to parallelize)\nvoid matrixMultiply(const Matrix& A, const Matrix& B, Matrix& C) {\n    for (size_t i = 0; i < A.getRows(); i++) {\n        for (siz",
    "confidence": 0.95
  },
  "3b07dcbe1a423113f30eb64d52936ae743fc5a1d3538dd0b158e87b07f4596be": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833315.89615,
    "usage_count": 1,
    "pattern_hash": "3b07dcbe1a423113f30eb64d52936ae743fc5a1d3538dd0b158e87b07f4596be",
    "original_code_snippet": "// Parallel candidate with reduction - matrix norm\ndouble matrixFrobeniusNorm(const Matrix& A) {\n    double sum = 0.0;\n    for (size_t i = 0; i < A.getRows(); i++) {\n        for (size_t j = 0; j < A.g",
    "confidence": 0.95
  },
  "be0191a499641434ec290e7e5613a384d15d9eb8f94bfcac46314ecf5b8a2665": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.9,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833315.8967822,
    "usage_count": 1,
    "pattern_hash": "be0191a499641434ec290e7e5613a384d15d9eb8f94bfcac46314ecf5b8a2665",
    "original_code_snippet": "// Complex pattern - matrix multiplication (trickier to parallelize)\nvoid matrixMultiply(const Matrix& A, const Matrix& B, Matrix& C) {\n    for (size_t i = 0; i < A.getRows(); i++) {\n        for (size",
    "confidence": 0.9
  },
  "879a599df7f888424df69b04cbb740c7501b62c1dbd9fd1dbce034e61c911916": {
    "analysis": {
      "classification": "not_parallel",
      "reasoning": "Static analysis identifies this as simple_loop; positive indicators found in code context",
      "confidence": 0.55,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833315.89746,
    "usage_count": 1,
    "pattern_hash": "879a599df7f888424df69b04cbb740c7501b62c1dbd9fd1dbce034e61c911916",
    "original_code_snippet": "    Matrix A(N, N), B(N, N), C(N, N);\n    \n    // Initialize matrices\n    for (size_t i = 0; i < N; i++) {\n        for (size_t j = 0; j < N; j++) {\n            A(i, j) = static_cast<double>(i + j);\n  ",
    "confidence": 0.55
  },
  "4459df57790d6cc35594493c13f4a346b2d9f3bda9eb174dbab9cda1013ecf85": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833316.5221279,
    "usage_count": 1,
    "pattern_hash": "4459df57790d6cc35594493c13f4a346b2d9f3bda9eb174dbab9cda1013ecf85",
    "original_code_snippet": "// Dot product - reduction with two arrays\ndouble dotProduct(const std::vector<double>& a, const std::vector<double>& b) {\n    double sum = 0.0;\n    for (size_t i = 0; i < a.size(); i++) {\n        sum",
    "confidence": 0.95
  },
  "48aa6a7219abcee8872ce20f364581636746af15e0d8fa3b0bee2b8f602059b4": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833316.52296,
    "usage_count": 1,
    "pattern_hash": "48aa6a7219abcee8872ce20f364581636746af15e0d8fa3b0bee2b8f602059b4",
    "original_code_snippet": "std::vector<double> runningSum(const std::vector<double>& data) {\n    std::vector<double> result(data.size());\n    result[0] = data[0];\n    for (size_t i = 1; i < data.size(); i++) {\n        result[i]",
    "confidence": 0.95
  },
  "262ebf74ce48cf7c15547e3fed25ae22b3ea950ecce56600f5e98b8ca9751cac": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833316.5236359,
    "usage_count": 1,
    "pattern_hash": "262ebf74ce48cf7c15547e3fed25ae22b3ea950ecce56600f5e98b8ca9751cac",
    "original_code_snippet": "// Simple reduction - sum\ndouble sumReduction(const std::vector<double>& data) {\n    double sum = 0.0;\n    for (size_t i = 0; i < data.size(); i++) {\n        sum += data[i];\n    }\n    return sum;",
    "confidence": 0.95
  },
  "5d9d9ea1371008cfdb32e56a4e26cf70f6b3edfcbbaf9cca4764ba9fd0b0f32c": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as embarrassingly_parallel; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp parallel for"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833316.524339,
    "usage_count": 1,
    "pattern_hash": "5d9d9ea1371008cfdb32e56a4e26cf70f6b3edfcbbaf9cca4764ba9fd0b0f32c",
    "original_code_snippet": "    for (size_t i = 1; i < data.size(); i++) {\n        if (data[i] > maxVal) {\n            maxVal = data[i];\n        }\n    }\n    return maxVal;\n}",
    "confidence": 0.95
  },
  "7c17e38a274b60f4f161d5c8bcab39ef8a9e8414b23151bc16b2548b67091b3b": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833316.5251682,
    "usage_count": 1,
    "pattern_hash": "7c17e38a274b60f4f161d5c8bcab39ef8a9e8414b23151bc16b2548b67091b3b",
    "original_code_snippet": "// Max reduction\ndouble maxReduction(const std::vector<double>& data) {\n    double maxVal = data[0];\n    for (size_t i = 1; i < data.size(); i++) {\n        if (data[i] > maxVal) {\n            maxVal =",
    "confidence": 0.95
  },
  "8c95ea39b2404cd0d72d641151de314f1346532ccba63d06cfb7c3fd65dffb5d": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.9,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833317.021268,
    "usage_count": 1,
    "pattern_hash": "8c95ea39b2404cd0d72d641151de314f1346532ccba63d06cfb7c3fd65dffb5d",
    "original_code_snippet": "    double kernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n    \n    for (int i = 1; i < N-1; i++) {\n        for (int j = 1; j < N-1; j++) {\n            double sum = 0.0;\n            for (int",
    "confidence": 0.9
  },
  "fd046a232c7720416b56d57859b8a8aecdf7d0be868fed07b7807a4f525cb431": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833317.022159,
    "usage_count": 1,
    "pattern_hash": "fd046a232c7720416b56d57859b8a8aecdf7d0be868fed07b7807a4f525cb431",
    "original_code_snippet": "    // 9-point stencil\n    \n    for (int i = 1; i < N-1; i++) {\n        for (int j = 1; j < N-1; j++) {\n            global_new_grid[i][j] = (\n                global_grid[i-1][j-1] + global_grid[i-1][j",
    "confidence": 0.95
  },
  "aa073518de576c1e8545df9efc4928b0f8076a7e46398bc6ff3fa98c17238a5a": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833317.025375,
    "usage_count": 1,
    "pattern_hash": "aa073518de576c1e8545df9efc4928b0f8076a7e46398bc6ff3fa98c17238a5a",
    "original_code_snippet": "    // Simple image blur\n    \n    for (int i = 1; i < M-1; i++) {\n        for (int j = 1; j < M-1; j++) {\n            int sum = global_image_big[i-1][j-1] + global_image_big[i-1][j] + global_image_big",
    "confidence": 0.95
  },
  "acb4c52a6cae58c4ca61dd43d9dd386f96666cfd6db8dff1e3424215fbf79836": {
    "analysis": {
      "classification": "safe_parallel",
      "reasoning": "Static analysis identifies this as vectorizable; positive indicators found in code context",
      "confidence": 0.95,
      "transformations": [
        "#pragma omp simd",
        "Enable compiler auto-vectorization"
      ],
      "tests_recommended": [
        "Compare parallel vs sequential results",
        "Performance benchmarking",
        "Verify SIMD instruction generation"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833317.026109,
    "usage_count": 1,
    "pattern_hash": "acb4c52a6cae58c4ca61dd43d9dd386f96666cfd6db8dff1e3424215fbf79836",
    "original_code_snippet": "    // 2D stencil - 5-point stencil (heat equation)\n    \n    for (int i = 1; i < N-1; i++) {\n        for (int j = 1; j < N-1; j++) {\n            global_new_grid[i][j] = (global_grid[i-1][j] + global_g",
    "confidence": 0.95
  },
  "5ca7d3174849355bf8a96dddc3b61d924e97c07c50b91847b1bc82d6de7ca5bf": {
    "analysis": {
      "classification": "not_parallel",
      "reasoning": "Static analysis identifies this as simple_loop; positive indicators found in code context",
      "confidence": 0.55,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833317.02696,
    "usage_count": 1,
    "pattern_hash": "5ca7d3174849355bf8a96dddc3b61d924e97c07c50b91847b1bc82d6de7ca5bf",
    "original_code_snippet": "    // 2D convolution with 3x3 kernel\n    double kernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n    \n    for (int i = 1; i < N-1; i++) {\n        for (int j = 1; j < N-1; j++) {\n            ",
    "confidence": 0.55
  },
  "457bc5a79106fbee5d8b58a0080a23ca2f7e10c9732bc043931ab9201ece5d53": {
    "analysis": {
      "classification": "not_parallel",
      "reasoning": "Static analysis identifies this as simple_loop; positive indicators found in code context",
      "confidence": 0.55,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833317.027785,
    "usage_count": 1,
    "pattern_hash": "457bc5a79106fbee5d8b58a0080a23ca2f7e10c9732bc043931ab9201ece5d53",
    "original_code_snippet": "    for (int i = 1; i < N-1; i++) {\n        for (int j = 1; j < N-1; j++) {\n            double sum = 0.0;\n            for (int ki = -1; ki <= 1; ki++) {\n                for (int kj = -1; kj <= 1; kj++",
    "confidence": 0.55
  },
  "a95332e544d9e59c7f675397119a3123a37fdb900fc554ede232f42b9975f9f1": {
    "analysis": {
      "classification": "requires_runtime_check",
      "reasoning": "Static analysis identifies this as simple_loop; positive indicators found in code context",
      "confidence": 0.6,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833317.028502,
    "usage_count": 1,
    "pattern_hash": "a95332e544d9e59c7f675397119a3123a37fdb900fc554ede232f42b9975f9f1",
    "original_code_snippet": "void stencil_2d_9point() {\n    // 9-point stencil\n    \n    for (int i = 1; i < N-1; i++) {\n        for (int j = 1; j < N-1; j++) {\n            global_new_grid[i][j] = (\n                global_grid[i-1",
    "confidence": 0.6
  },
  "506d8bee5c97e33967a8db0e09d7e3aa99b4c9ff187d12da346adb71437549db": {
    "analysis": {
      "classification": "requires_runtime_check",
      "reasoning": "Static analysis identifies this as simple_loop; positive indicators found in code context",
      "confidence": 0.6,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833317.029279,
    "usage_count": 1,
    "pattern_hash": "506d8bee5c97e33967a8db0e09d7e3aa99b4c9ff187d12da346adb71437549db",
    "original_code_snippet": "void image_blur() {\n    // Simple image blur\n    \n    for (int i = 1; i < M-1; i++) {\n        for (int j = 1; j < M-1; j++) {\n            int sum = global_image_big[i-1][j-1] + global_image_big[i-1][j",
    "confidence": 0.6
  },
  "86802635c968ffd3e0eabedf3bbfb02d1ee9b4457af563a0009e5c7c0a447825": {
    "analysis": {
      "classification": "requires_runtime_check",
      "reasoning": "Static analysis identifies this as simple_loop; positive indicators found in code context",
      "confidence": 0.6,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833317.0300548,
    "usage_count": 1,
    "pattern_hash": "86802635c968ffd3e0eabedf3bbfb02d1ee9b4457af563a0009e5c7c0a447825",
    "original_code_snippet": "void stencil_2d_simple() {\n    // 2D stencil - 5-point stencil (heat equation)\n    \n    for (int i = 1; i < N-1; i++) {\n        for (int j = 1; j < N-1; j++) {\n            global_new_grid[i][j] = (glo",
    "confidence": 0.6
  },
  "6f4a2034803d77786d050741d96dead34cecc9bebdbc0898edb75545c574fe36": {
    "analysis": {
      "classification": "not_parallel",
      "reasoning": "Static analysis identifies this as risky; positive indicators found in code context",
      "confidence": 0.55,
      "transformations": [
        "Manual parallelization analysis required"
      ],
      "tests_recommended": [
        "Thorough dependency analysis required",
        "Compare parallel vs sequential results",
        "Performance benchmarking"
      ],
      "logic_issue_type": "none",
      "analysis_source": "heuristic_analysis"
    },
    "timestamp": 1759833317.03081,
    "usage_count": 1,
    "pattern_hash": "6f4a2034803d77786d050741d96dead34cecc9bebdbc0898edb75545c574fe36",
    "original_code_snippet": "        for (int j = 1; j < N-1; j++) {\n            double sum = 0.0;\n            for (int ki = -1; ki <= 1; ki++) {\n                for (int kj = -1; kj <= 1; kj++) {\n                    sum += globa",
    "confidence": 0.55
  }
}